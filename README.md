# x86アセンブラでOSレスのズンドコきよし #

x86 CPUの電源投入後の動作モードであるリアルモード(16ビットモード)向けに、アセンブラでズンドコきよしのプログラムを書いてみました。

OSレスで動作するように作っていますので、生成されるイメージ`zundoko.img`は以下のようにQEMUで実行できます。

```
$ qemu-system-i386 -fda zundoko.img
```

## 必要なもの ##

- GCC
- Make
- QEMU(qemu-system-i386)

## 試し方 ##

Makefileを用意していますので、`make run`でビルドと動作確認を行えます。

## ズンドコきよし自体のアルゴリズム ##

C言語で同等の実装を行ったものを`zundoko_algo.c`という名前でこのリポジトリに入れています。

ズンドコきよしの解き方としては、以下のように考えました。

1. zunカウンタゼロクリア
2. 乱数生成(0か1)
3. ループ
   1. 乱数 == 1
      1. print "zun"
      2. zunカウンタインクリメント
   2. 乱数 == 0
      1. print "doko"
      2. zunカウンタ < 4
         1. zunカウンタゼロクリア
      3. zunカウンタ >= 4
         1. ループ脱出
4. print "kiyoshi"

## OSレスのアセンブラで実現するためにやったこと ##

乱数の種のためのタイマーカウンタ値取得と、画面への文字出力は、BIOSの機能を呼び出すことで実現しています。([BIOS割り込みルーチン](https://ja.wikipedia.org/wiki/BIOS%E5%89%B2%E3%82%8A%E8%BE%BC%E3%81%BF%E3%83%AB%E3%83%BC%E3%83%81%E3%83%B3))

また、乱数を生成する機能はBIOSに無いので、[線形合同法](https://ja.wikipedia.org/wiki/%E7%B7%9A%E5%BD%A2%E5%90%88%E5%90%8C%E6%B3%95)という方法で実装しました。

## すべてのデータをレジスタで管理 ##

ズンドコきよしと乱数生成のアルゴリズムは共に、「記憶しておかなければならないデータ」が少ないアルゴリズムです。

- ズンドコきよし -- zunカウンタのみ
- 乱数生成(線形合同法) -- 漸化式の演算結果(Xn)のみ

そこで、すべてのデータをレジスタで管理し、メモリへのread/writeを行わないように作ってみました。(ただし、CPUが実行する命令をメモリから取り出す(フェッチ)ためのreadは例外。命令フェッチのためのread以外にメモリアクセスは発生しないように作ってみました。)

`zundoko.S`で使用するレジスタは以下のとおりです。

レジスタ名|用途
:--|:--
ax,bx,cx,dx|演算のための値格納、BIOS割り込みルーチンへの値受け渡し
di|zunカウンタ
si|漸化式の演算結果(Xn)
